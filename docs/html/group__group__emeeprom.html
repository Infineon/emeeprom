<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Emulated EEPROM (emeeprom)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Emulated EEPROM (emeeprom)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group__emeeprom.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Em_EEPROM Middleware Library</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p >The Emulated EEPROM (Em_EEPROM) middleware emulates an EEPROM storage in the MCU's non volatile memory and it is built on top of a block storage devie that abstracts the underlying memory architecture so that the middleware is portable to a wide range of devices. </p>
<p >Use the Em_EEPROM to store non-volatile data on a target device when increasing flash memory endurance and restoring corrupted data from a redundant copy is required.</p>
<p ><b>Features:</b></p><ul>
<li>EEPROM-Like Non-Volatile Storage</li>
<li>Easy to use Read and Write</li>
<li>Optional Wear Leveling</li>
<li>Optional Redundant Data Storage</li>
</ul>
<h1><a class="anchor" id="section_em_eeprom_general_description"></a>
General Description</h1>
<p >Include cy_em_eeprom.h to get access to all functions and other declarations in this library. See the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_quick_start">Quick Start Guide</a> to start using the Em_EEPROM.</p>
<p >Refer to the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_toolchain">Supported Software and Tools</a> section for compatibility information.</p>
<p >Refer to the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_changelog">Changelog</a> section for differences between Em_EEPROM versions. The <a class="el" href="group__group__emeeprom.html#section_em_eeprom_changelog">Changelog</a> section also describes the impact of the changes to your code.</p>
<p >Em_EEPROM operates on the top of the block storage solution. Refer to the block storage asset documentation for more information. Also, refer to the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_miscellaneous">Limitations and Restrictions</a> section for the different Em_EEPROM middleware restrictions and limitations.</p>
<p >The Em_EEPROM middleware can operate in various modes:</p><ul>
<li>with or without wear leveling - depending on whether you want to increase the endurance of the nvm memory.</li>
<li>with or without a redundant copy - depending on how critical for you is the ability to recover information.</li>
<li>to save nvm and work via Em_EEPROM APIs similar to the nvm APIs. But, in this case, recovering your data and monitoring the endurance is impossible.</li>
</ul>
<p >There are several use cases depending on where you store your Em_EEPROM data:</p><ul>
<li>in the application flash</li>
<li>in the auxiliary flash</li>
<li>in the application flash at a fixed address.</li>
</ul>
<p >Note: refer to device capabilities for supported storage location for EM_EEPROM data.</p>
<p >The <a class="el" href="group__group__emeeprom.html#section_em_eeprom_configuration_considerations">Configuration Considerations</a> section provides the guidance for all these operation modes and use cases. You may also want to migrate from PSoC Creator to ModusToolbox or other environment to simply use the Em_EEPROM middleware APIs. Refer to the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_migration">Migration from PSoC Creator</a> section.</p>
<p >The <a class="el" href="group__group__emeeprom.html#section_em_eeprom_quick_start">Quick Start Guide</a> section highlights the use case, when the Em_EEPROM data is located in the application flash, and the Em_EEPROM is configured to increase the flash endurance (the wearLevelingFactor parameter is turned on).</p>
<h1><a class="anchor" id="section_em_eeprom_xmc7xxx"></a>
XMC7xxx and T2G-B-H Em_EEPROM storage restrictions</h1>
<p >XMC7xxx and T2G-B-H based devices support Em_EEPROM Data only in "Work Flash". The "Work Flash" provides sectors with 2 sizes namely: Large (2 kbytes) and Small (128 bytes). The user should select which type of Work FLash region will be used for Em_EEPROM storage specifying the start address in the config structure.</p>
<p >Using EEPROM Personality: The EEPROM personality has checkbox for: "Work Flash Sector Selection default Small Sector" which is "checked" by default. To use Large sector work flash, uncheck this box.</p>
<h1><a class="anchor" id="section_em_eeprom_quick_start"></a>
Quick Start Guide</h1>
<p >Em_EEPROM middleware can be used in various Development Environments such as ModusToolbox, Mbed OS, etc. Refer to the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_toolchain">Supported Software and Tools</a> section.</p>
<p >The below steps describe the simplest way of enabling the Em_EEPROM middleware with placing EEPROM memory into the application flash.</p>
<ol type="1">
<li>Open/Create an application where to add the Em_EEPROM function.</li>
<li>Add the Em_EEPROM middleware to your project. This quick start guide assumes that the environment is configured to use the Peripheral Driver Library (mtb-pdl-cat1 or mtb-pdl-cat2) and the Hardware Abstraction Layer (mtb-hal-cat1) for development and the Peripheral Driver Library is included in the project. If you are using the ModusToolbox development environment select the application in the Project Explorer window and navigate to the Project/ModusToolbox Library Manager menu. A window appears, check the Emulated EEPROM middleware and click the OK button.</li>
<li>Include Em_EEPROM in the main.c file: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cy_em_eeprom.h&quot;</span></div>
</div><!-- fragment --></li>
<li>Define the Em_EEPROM configuration as follow: <div class="fragment"><div class="line"><span class="comment">/* The size of data to store in EEPROM for devices that have flash memory</span></div>
<div class="line"><span class="comment"> *  */</span></div>
<div class="line"><span class="preprocessor">#define DATA_SIZE                       (CY_FLASH_SIZEOF_ROW)</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">/* The Simple Mode is turned off */</span></div>
<div class="line"><span class="preprocessor">#define SIMPLE_MODE                     (0u)</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">/* Increases the flash endurance twice */</span></div>
<div class="line"><span class="preprocessor">#define WEAR_LEVELING                   (2u)</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">/* The Redundant Copy is turned off */</span></div>
<div class="line"><span class="preprocessor">#define REDUNDANT_COPY                  (0u)</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">/* The Blocking Write is turned on */</span></div>
<div class="line"><span class="preprocessor">#define BLOCKING_WRITE                  (1u)</span></div>
</div><!-- fragment --> Refer to the <a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__config__t">cy_stc_eeprom_config_t</a> or <a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__config2__t">cy_stc_eeprom_config2_t</a> structure for details of other configuration options.</li>
<li>Declare the Em_EEPROM storage variable (further Em_EEPROM Storage) in the application nvm: <div class="fragment"><div class="line">CY_ALIGN(DATA_SIZE)</div>
<div class="line"><span class="keyword">const</span> uint8_t emEepromStorage[CY_EM_EEPROM_GET_PHYSICAL_SIZE(DATA_SIZE, SIMPLE_MODE, WEAR_LEVELING,</div>
<div class="line">                                                             REDUNDANT_COPY)] = { 0u };</div>
</div><!-- fragment --> The allocated memory must be initialized by zeros, and aligned to the whole row size CY_EM_EEPROM_FLASH_SIZEOF_ROW for Flash based products, otherwise the Em_EEPROM middleware behavior will be unexpected.<br  />
 Refer to the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_configuration_considerations">Configuration Considerations</a> section for other options of Em_EEPROM nvm allocation.</li>
<li>Allocate memory for the Em_EEPROM context structure: <div class="fragment"><div class="line">    <a class="code hl_struct" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a> eepromContext;</div>
<div class="ttc" id="agroup__group__emeeprom_html_structcy__stc__eeprom__context__t"><div class="ttname"><a href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a></div><div class="ttdoc">The Em_EEPROM context data structure.</div><div class="ttdef"><b>Definition:</b> cy_em_eeprom.h:1147</div></div>
</div><!-- fragment --></li>
<li>Allocate memory for the Em_EEPROM configuration structure and initialize it: <div class="fragment"><div class="line">    <a class="code hl_struct" href="group__group__emeeprom.html#structcy__stc__eeprom__config__t">cy_stc_eeprom_config_t</a> eepromConfig =</div>
<div class="line">    {</div>
<div class="line">        .<a class="code hl_variable" href="group__group__emeeprom.html#ad41b3c5ce4619d484a648a5a4bcc0bad">eepromSize</a>           = DATA_SIZE,</div>
<div class="line">        .simpleMode           = SIMPLE_MODE,</div>
<div class="line">        .wearLevelingFactor   = WEAR_LEVELING,</div>
<div class="line">        .redundantCopy        = REDUNDANT_COPY,</div>
<div class="line">        .blockingWrite        = 1u,</div>
<div class="line">        .userFlashStartAddr   = (uint32_t)&amp;(emEepromStorage[0u]),</div>
<div class="line">    };</div>
<div class="ttc" id="agroup__group__emeeprom_html_ad41b3c5ce4619d484a648a5a4bcc0bad"><div class="ttname"><a href="group__group__emeeprom.html#ad41b3c5ce4619d484a648a5a4bcc0bad">cy_stc_eeprom_config_t::eepromSize</a></div><div class="ttdeci">uint32_t eepromSize</div><div class="ttdoc">The logical size of data in bytes to store in the Em_EEPROM.</div><div class="ttdef"><b>Definition:</b> cy_em_eeprom.h:1019</div></div>
<div class="ttc" id="agroup__group__emeeprom_html_structcy__stc__eeprom__config__t"><div class="ttname"><a href="group__group__emeeprom.html#structcy__stc__eeprom__config__t">cy_stc_eeprom_config_t</a></div><div class="ttdoc">Em_EEPROM configuration structure.</div><div class="ttdef"><b>Definition:</b> cy_em_eeprom.h:1006</div></div>
</div><!-- fragment --> or <div class="fragment"><div class="line">    <a class="code hl_struct" href="group__group__emeeprom.html#structcy__stc__eeprom__config2__t">cy_stc_eeprom_config2_t</a> eepromNewConfig =</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Example of emeeprom storage of logic size 128 bytes,</span></div>
<div class="line"><span class="comment">           with simple mode set to 0, wear leveling enabled to</span></div>
<div class="line"><span class="comment">           level 4 and redundant copy enabled. */</span></div>
<div class="line">        .<a class="code hl_variable" href="group__group__emeeprom.html#ab7fc595ca299793465899b58460c0238">eepromSize</a>           = 128u,</div>
<div class="line">        .simpleMode           = 0u,</div>
<div class="line">        .wearLevelingFactor   = 4u,</div>
<div class="line">        .redundantCopy        = 1u,</div>
<div class="line">        .blockingWrite        = 1u,</div>
<div class="line">        .userNvmStartAddr     = (uint32_t)&amp;(emEepromStorage[0u]),</div>
<div class="line">    };</div>
<div class="ttc" id="agroup__group__emeeprom_html_ab7fc595ca299793465899b58460c0238"><div class="ttname"><a href="group__group__emeeprom.html#ab7fc595ca299793465899b58460c0238">cy_stc_eeprom_config2_t::eepromSize</a></div><div class="ttdeci">uint32_t eepromSize</div><div class="ttdoc">The logical size of data in bytes to store in the Em_EEPROM.</div><div class="ttdef"><b>Definition:</b> cy_em_eeprom.h:1087</div></div>
<div class="ttc" id="agroup__group__emeeprom_html_structcy__stc__eeprom__config2__t"><div class="ttname"><a href="group__group__emeeprom.html#structcy__stc__eeprom__config2__t">cy_stc_eeprom_config2_t</a></div><div class="ttdoc">Em_EEPROM new configuration structure.</div><div class="ttdef"><b>Definition:</b> cy_em_eeprom.h:1074</div></div>
</div><!-- fragment --></li>
<li>Initialize the Em_EEPROM middleware once at the start: <div class="fragment"><div class="line">    <span class="keywordflow">if</span> (CY_RSLT_SUCCESS != <a class="code hl_function" href="group__group__emeeprom.html#gab9f608d788f1a854b10c652c3bb00fdd">Cy_Em_EEPROM_Init</a>(&amp;eepromConfig, &amp;eepromContext))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Error check action</span></div>
<div class="line">    }</div>
<div class="ttc" id="agroup__group__emeeprom_html_gab9f608d788f1a854b10c652c3bb00fdd"><div class="ttname"><a href="group__group__emeeprom.html#gab9f608d788f1a854b10c652c3bb00fdd">Cy_Em_EEPROM_Init</a></div><div class="ttdeci">cy_en_em_eeprom_status_t Cy_Em_EEPROM_Init(const cy_stc_eeprom_config_t *config, cy_stc_eeprom_context_t *context)</div><div class="ttdoc">This function was the entry point up until version 2.20.</div><div class="ttdef"><b>Definition:</b> cy_em_eeprom.c:79</div></div>
</div><!-- fragment --> or <div class="fragment"><div class="line">    <span class="comment">/* Example showcasing the initialization of a block storage device object based on HAL NVM */</span></div>
<div class="line">    mtb_block_storage_t my_bsd;</div>
<div class="line">    <span class="keywordflow">if</span> (CY_RSLT_SUCCESS == mtb_block_storage_nvm_create(&amp;my_bsd))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (CY_RSLT_SUCCESS != <a class="code hl_function" href="group__group__emeeprom.html#ga4002a38fb2fd80487dc58eb4518a471f">Cy_Em_EEPROM_Init_BD</a>(&amp;eepromNewConfig, &amp;eepromContext, &amp;my_bsd))</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//Error check action</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Error check action</span></div>
<div class="line">    }</div>
<div class="ttc" id="agroup__group__emeeprom_html_ga4002a38fb2fd80487dc58eb4518a471f"><div class="ttname"><a href="group__group__emeeprom.html#ga4002a38fb2fd80487dc58eb4518a471f">Cy_Em_EEPROM_Init_BD</a></div><div class="ttdeci">cy_en_em_eeprom_status_t Cy_Em_EEPROM_Init_BD(const cy_stc_eeprom_config2_t *config, cy_stc_eeprom_context_t *context, mtb_block_storage_t *block_device)</div><div class="ttdoc">Initializes the Emulated EEPROM library by filling the context structure.</div><div class="ttdef"><b>Definition:</b> cy_em_eeprom.c:111</div></div>
</div><!-- fragment --> or <div class="fragment"><div class="line">    <span class="comment">/* Example showcasing the initialization of a block storage device object based on HAL NVM */</span></div>
<div class="line">    mtb_block_storage_t my_bsd;</div>
<div class="line">    <span class="keywordflow">if</span> (CY_RSLT_SUCCESS == mtb_block_storage_cat2_create(&amp;my_bsd))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (CY_RSLT_SUCCESS != <a class="code hl_function" href="group__group__emeeprom.html#ga4002a38fb2fd80487dc58eb4518a471f">Cy_Em_EEPROM_Init_BD</a>(&amp;eepromNewConfig, &amp;eepromContext, &amp;my_bsd))</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//Error check action</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Error check action</span></div>
<div class="line">    }</div>
</div><!-- fragment --> Init function stores in context, the configuration and current state of EEPROM storage. It is used and updated in subsequent API calls.</li>
<li>Now, the Em_EEPROM middleware is ready to use. Call the Write or Read functions to write or read one byte or Erase to wipe the storage: <div class="fragment"><div class="line">    uint8_t readData = 0xAAu;</div>
<div class="line">    <span class="keywordflow">if</span> (CY_RSLT_SUCCESS != <a class="code hl_function" href="group__group__emeeprom.html#gaa792ff05d2b6ee71b44f1faeb2b68886">Cy_Em_EEPROM_Write</a>(0u, &amp;readData, 1u, &amp;eepromContext))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Error check action</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (CY_RSLT_SUCCESS != <a class="code hl_function" href="group__group__emeeprom.html#ga9e14084e3054f6f147004d2914f9216d">Cy_Em_EEPROM_Read</a>(0u, &amp;readData, 1u, &amp;eepromContext))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Error check action</span></div>
<div class="line">    }</div>
<div class="ttc" id="agroup__group__emeeprom_html_ga9e14084e3054f6f147004d2914f9216d"><div class="ttname"><a href="group__group__emeeprom.html#ga9e14084e3054f6f147004d2914f9216d">Cy_Em_EEPROM_Read</a></div><div class="ttdeci">cy_en_em_eeprom_status_t Cy_Em_EEPROM_Read(uint32_t addr, void *eepromData, uint32_t size, cy_stc_eeprom_context_t *context)</div><div class="ttdoc">Reads data from a specified location.</div><div class="ttdef"><b>Definition:</b> cy_em_eeprom.c:185</div></div>
<div class="ttc" id="agroup__group__emeeprom_html_gaa792ff05d2b6ee71b44f1faeb2b68886"><div class="ttname"><a href="group__group__emeeprom.html#gaa792ff05d2b6ee71b44f1faeb2b68886">Cy_Em_EEPROM_Write</a></div><div class="ttdeci">cy_en_em_eeprom_status_t Cy_Em_EEPROM_Write(uint32_t addr, const void *eepromData, uint32_t size, cy_stc_eeprom_context_t *context)</div><div class="ttdoc">Writes data to a specified location.</div><div class="ttdef"><b>Definition:</b> cy_em_eeprom.c:470</div></div>
</div><!-- fragment --> and <div class="fragment"><div class="line">    <span class="keywordflow">if</span> (CY_RSLT_SUCCESS != <a class="code hl_function" href="group__group__emeeprom.html#gad61dbc3c01d2bbf96e0c0d5b6d2e0b61">Cy_Em_EEPROM_Erase</a>(&amp;eepromContext))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Error check action</span></div>
<div class="line">    }</div>
<div class="ttc" id="agroup__group__emeeprom_html_gad61dbc3c01d2bbf96e0c0d5b6d2e0b61"><div class="ttname"><a href="group__group__emeeprom.html#gad61dbc3c01d2bbf96e0c0d5b6d2e0b61">Cy_Em_EEPROM_Erase</a></div><div class="ttdeci">cy_en_em_eeprom_status_t Cy_Em_EEPROM_Erase(cy_stc_eeprom_context_t *context)</div><div class="ttdoc">This function erases the entire content of Em_EEPROM.</div><div class="ttdef"><b>Definition:</b> cy_em_eeprom.c:706</div></div>
</div><!-- fragment --></li>
</ol>
<h1><a class="anchor" id="section_em_eeprom_configuration_considerations"></a>
Configuration Considerations</h1>
<p >This section consists of different guides and instruction of how to enable, configure, and use the Emulated EEPROM Middleware in a design. As you can see from the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_quick_start">Quick Start Guide</a> section, the settings of the Em_EEPROM middleware are controlled with the <a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__config__t">cy_stc_eeprom_config_t</a> structure. Please see its description to learn about the parameters and values.</p>
<p >Now we will describe the most common use cases along with the configuration structure examples and code snippets. The list of sections under Configuration Considerations:</p>
<ul>
<li><a class="el" href="group__group__emeeprom.html#section_em_eeprom_operating_modes">Operating Modes</a><ul>
<li><a class="el" href="group__group__emeeprom.html#section_em_eeprom_mode_wearleveling">Wear Leveling</a></li>
<li><a class="el" href="group__group__emeeprom.html#section_em_eeprom_mode_redundantcopy">Redundant Copy</a></li>
<li><a class="el" href="group__group__emeeprom.html#section_em_eeprom_mode_simple">Simple Mode</a></li>
</ul>
</li>
<li><a class="el" href="group__group__emeeprom.html#section_em_eeprom_location">Em_EEPROM Storage Variable Location and Size</a><ul>
<li><a class="el" href="group__group__emeeprom.html#section_em_eeprom_appsflash_location">Em_EEPROM Location in the application flash</a></li>
<li><a class="el" href="group__group__emeeprom.html#section_em_eeprom_auxflash_location">Em_EEPROM Location in the auxiliary flash</a></li>
<li><a class="el" href="group__group__emeeprom.html#section_em_eeprom_appsflash_fixed">Em_EEPROM Location in the application flash at a</a></li>
</ul>
</li>
<li><a class="el" href="group__group__emeeprom.html#section_em_eeprom_migration">Migration from PSoC Creator</a></li>
</ul>
<p >Also refer to the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_miscellaneous">Limitations and Restrictions</a> for the existing restrictions.</p>
<h2><a class="anchor" id="section_em_eeprom_operating_modes"></a>
Operating Modes</h2>
<p >The settings of the Em_EEPROM middleware are controlled by the <a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__config__t">cy_stc_eeprom_config_t</a> structure. See its description to learn about the parameters and values.</p>
<h3><a class="anchor" id="section_em_eeprom_mode_wearleveling"></a>
Wear Leveling</h3>
<p >Depending on whether you want to increase the flash memory endurance or not, enable or disable the wear leveling. The higher the value is, the more flash is used, but a higher number of erase/write cycles can be done on Em_EEPROM. Multiply this number by the datasheet write endurance spec to determine the max of write cycles.<br  />
 The amount of wear leveling from 1 to 10. 1 means no wear leveling is used.</p>
<p >To configure the wear leveling just set the WEAR_LEVELING macro value from (1u) to (10u) in step #4 in the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_quick_start">Quick Start Guide</a> section: </p><div class="fragment"><div class="line"><span class="comment">/* Increases the flash endurance twice */</span></div>
<div class="line"><span class="preprocessor">#define WEAR_LEVELING                   (2u)</span></div>
</div><!-- fragment --><h3><a class="anchor" id="section_em_eeprom_mode_redundantcopy"></a>
Redundant Copy</h3>
<p >Depending on how critical for you is recovering information, configure the redundant copy feature. If enabled (1 - enabled, 0 - disabled), a checksum (stored in a row) is calculated on each row of data, while a redundant copy of Em_EEPROM is stored in another location. When data is read, first the checksum is checked. If that checksum is bad, and the redundant copy's checksum is good, the copy is restored.</p>
<p >To configure the redundant copy just set the REDUNDANT_COPY macro value to (1u) or (0u) in step #4 in the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_quick_start">Quick Start Guide</a> section: </p><div class="fragment"><div class="line"><span class="comment">/* The Redundant Copy is turned off */</span></div>
<div class="line"><span class="preprocessor">#define REDUNDANT_COPY                  (0u)</span></div>
</div><!-- fragment --><h3><a class="anchor" id="section_em_eeprom_mode_simple"></a>
Simple Mode</h3>
<p >Simple mode, when enabled (1 - enabled, 0 - disabled), means no additional service information is stored by the Em_EEPROM middleware like checksums, headers, a number of writes, etc. Data is stored directly by the specified address. The size of Em_EEPROM storage is equal to the number of byte specified in the eepromSize parameter rounded up to a full row size CY_EM_EEPROM_FLASH_SIZEOF_ROW. The wear leveling and redundant copy features are disabled, i.e. wearLevelingFactor and redundantCopy parameters are ignored.</p>
<p >To configure Simple mode just set the SIMPLE_MODE macro value to (1u) or (0u) in step #4 in the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_quick_start">Quick Start Guide</a> section: </p><div class="fragment"><div class="line"><span class="comment">/* The Simple Mode is turned off */</span></div>
<div class="line"><span class="preprocessor">#define SIMPLE_MODE                     (0u)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="section_em_eeprom_location"></a>
Em_EEPROM Storage Variable Location and Size</h2>
<p >The user is responsible for allocating space in flash for Em_EEPROM (further the Em_EEPROM storage).</p>
<p >For PSoC 6 the Em_EEPROM storage can be placed:</p><ul>
<li>in the application flash</li>
<li>in the auxiliary flash.</li>
</ul>
<p >Additionally, the storage can be placed at a fixed address in the application flash.</p>
<p >For PSoC 4 the Em_EEPROM storage can be placed:</p><ul>
<li>in the application flash</li>
</ul>
<p >Additionally, the storage can be placed at a fixed address in the application flash.</p>
<p >For XMC7xxx and T2G-B-H the Em_EEPROM storage can be placed:</p><ul>
<li>in the Work Flash region</li>
</ul>
<p >The storage location must be aligned to CY_EM_EEPROM_FLASH_SIZEOF_ROW.</p>
<p >The storage size depends on other configuration parameters and is calculated using the following equation:</p>
<ol type="1">
<li><p class="startli">Simple mode is turned on. It means the direct mapping of the user data in the Em_EEPROM storage:</p>
<p class="startli"><em>storageSize = eepromSize</em></p>
<p class="startli">where:<br  />
 <em>eepromSize</em> the number of bytes to store in the Em_EEPROM storage rounded up to a full row size CY_EM_EEPROM_FLASH_SIZEOF_ROW. The row size is specific for a device family. Refer to the specific PSoC device datasheet.</p>
</li>
<li><p class="startli">Simple mode is turned off. It means the Em_EEPROM middleware stores service information about number of writes, checksums, etc.</p>
<p class="startli"><em>storageSize = eepromSize * 2 * wearLevelingFactor * (1 + redundantCopy)</em></p>
<p class="startli">where:<br  />
 <em>eepromSize</em> the number of bytes to store in the Em_EEPROM storage rounded up to the half of a row size (CY_EM_EEPROM_FLASH_SIZEOF_ROW / 2u). The row size is specific for a device family. Refer to the specific PSoC device datasheet.</p>
</li>
</ol>
<p >Use the CY_EM_EEPROM_GET_PHYSICAL_SIZE() macro to get the needed storage size depending on the configuration.</p>
<h3><a class="anchor" id="section_em_eeprom_appsflash_location"></a>
Em_EEPROM Location in the application flash</h3>
<p >The below example shows placing the Em_EEPROM storage in the application flash for GCC, ARMCC, and IAR compilers:</p>
<div class="fragment"><div class="line">CY_ALIGN(CY_EM_EEPROM_FLASH_SIZEOF_ROW)</div>
<div class="line"><span class="keyword">const</span> uint8_t emEepromStorage[STORAGE_SIZE] = {0u};</div>
</div><!-- fragment --><p >where STORAGE_SIZE is the size of the Em_EEPROM storage. Refer to the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_location">Em_EEPROM Storage Variable Location and Size</a> section for size calculation equations. For convenience, use the CY_EM_EEPROM_GET_PHYSICAL_SIZE macro to get the needed Em_EEPROM storage size depending on the configuration.</p>
<h3><a class="anchor" id="section_em_eeprom_auxflash_location"></a>
Em_EEPROM Location in the auxiliary flash</h3>
<p >Writes to rows affect the endurance of other rows in the same sector. We recommend using the auxiliary flash for frequently-updated data. The below example shows placing the Em_EEPROM storage in the auxiliary flash (section .cy_em_eeprom) for GCC, ARMCC, and IAR compilers.</p>
<div class="fragment"><div class="line">CY_SECTION(<span class="stringliteral">&quot;.cy_em_eeprom&quot;</span>)</div>
<div class="line">CY_ALIGN(CY_EM_EEPROM_FLASH_SIZEOF_ROW)</div>
<div class="line">const uint8_t emEepromStorage[STORAGE_SIZE] = {0u};</div>
</div><!-- fragment --><p >where STORAGE_SIZE is the size of the storage. Refer to the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_location">Em_EEPROM Storage Variable Location and Size</a> section for size calculation equations. For convenience, use the CY_EM_EEPROM_GET_PHYSICAL_SIZE macro to get the needed Em_EEPROM storage size depending on the configuration.</p>
<h2><a class="anchor" id="section_em_eeprom_appsflash_fixed"></a>
Em_EEPROM Location in the application flash at a</h2>
<p >fixed address</p>
<p >To allocate the Em_EEPROM storage at a fixed address in the application flash, modify the linker control file (linker script). This requires fundamental knowledge of the linker control file, because there is a risk of receiving a linker error while building the project if you make some improper modifications.</p>
<p >This approach demonstrates adding the storage reservation in the application flash after the application. You must calculate the application end address and select the address of the Em_EEPROM storage so that the memory spaces of the storage and the application do not overlap. You might also add some offset between the application end address and the Em_EEPROM storage start address to ensure there is extra space in case the project code grows.</p>
<h3><a class="anchor" id="section_em_eeprom_fixed_address_gcc"></a>
Em_EEPROM Storage at a Fixed Address for GCC</h3>
<p >Compiler</p>
<ol type="1">
<li>Build the project to generate linker scripts.</li>
<li>Open the linker script "cy8c6xxa_cm4_dual.ld" for the CM4 core and search the following declaration: <div class="fragment"><div class="line">etext =  . ;</div>
</div><!-- fragment --> Paste the following code right after the declaration: <div class="fragment"><div class="line">EM_EEPROM_START_ADDRESS = &lt;EEPROM Storage Address&gt;;</div>
<div class="line">.my_emulated_eeprom EM_EEPROM_START_ADDRESS :</div>
<div class="line">{</div>
<div class="line">   KEEP(*(.my_emulated_eeprom))</div>
<div class="line">} &gt; flash</div>
</div><!-- fragment --> where:<ul>
<li>EEPROM Storage Address is an absolute address in flash where the Em_EEPROM operates. You must define the address value. Ensure the address is aligned to the size of the device's flash row and does not overlap with the memory space used by the application.</li>
<li>my_emulated_eeprom is the name of the section where the Em_EEPROM storage will be placed. The name can be changed to any name you choose.</li>
</ul>
</li>
<li>Save the changes and close the file.</li>
<li>Declare the Em_EEPROM storage in the newly created section. To do this, declare an array in flash, aligned to the size of the flash row of the device you are using. An example of such array declaration is the following: <div class="fragment"><div class="line">CY_SECTION(<span class="stringliteral">&quot;.my_emulated_eeprom&quot;</span>)</div>
<div class="line">CY_ALIGN(CY_EM_EEPROM_FLASH_SIZEOF_ROW)</div>
<div class="line">const uint8 emEepromStorage[STORAGE_SIZE];</div>
</div><!-- fragment --></li>
<li>After the Em_EEPROM storage is defined, pass the address to the middleware: <div class="fragment"><div class="line">    <span class="comment">//Old configuration</span></div>
<div class="line">    eepromConfig.<a class="code hl_variable" href="group__group__emeeprom.html#a686ebc626fadcdce3ffc40406f707f49">userFlashStartAddr</a> = (uint32_t)&amp;(emEepromStorage[0u]);</div>
<div class="line">    <span class="comment">//New configuration</span></div>
<div class="line">    eepromNewConfig.<a class="code hl_variable" href="group__group__emeeprom.html#a293c254f31fe0bd80b801c82819de60f">userNvmStartAddr</a> = (uint32_t)&amp;(emEepromStorage[0u]);</div>
<div class="ttc" id="agroup__group__emeeprom_html_a293c254f31fe0bd80b801c82819de60f"><div class="ttname"><a href="group__group__emeeprom.html#a293c254f31fe0bd80b801c82819de60f">cy_stc_eeprom_config2_t::userNvmStartAddr</a></div><div class="ttdeci">uint32_t userNvmStartAddr</div><div class="ttdoc">The address of the nvm storage.</div><div class="ttdef"><b>Definition:</b> cy_em_eeprom.h:1137</div></div>
<div class="ttc" id="agroup__group__emeeprom_html_a686ebc626fadcdce3ffc40406f707f49"><div class="ttname"><a href="group__group__emeeprom.html#a686ebc626fadcdce3ffc40406f707f49">cy_stc_eeprom_config_t::userFlashStartAddr</a></div><div class="ttdeci">uint32_t userFlashStartAddr</div><div class="ttdoc">The address of the nvm storage.</div><div class="ttdef"><b>Definition:</b> cy_em_eeprom.h:1069</div></div>
</div><!-- fragment --></li>
<li>Build the project to verify the correctness of the linker control file modifications.</li>
</ol>
<h3><a class="anchor" id="section_em_eeprom_fixed_address_arm"></a>
Em_EEPROM Storage at a Fixed Address for ARM</h3>
<p >Compiler</p>
<ol type="1">
<li>Build the project to generate linker scripts.</li>
<li>Open the linker script "cy8c6xxa_cm4_dual.sct" for the CM4 core and search the following declaration: <div class="fragment"><div class="line">; Emulated EEPROM Flash area</div>
<div class="line">LR_EM_EEPROM EM_EEPROM_START EM_EEPROM_SIZE</div>
</div><!-- fragment --> Paste the following code right before the declaration: <div class="fragment"><div class="line"><span class="preprocessor">#define EM_EEPROM_START_ADDRESS &lt;EEPROM Storage Address&gt;</span></div>
<div class="line">EM_EEPROM (EM_EEPROM_START_ADDRESS)</div>
<div class="line">{</div>
<div class="line">   .my_emulated_eeprom+0</div>
<div class="line">   {</div>
<div class="line">       *(.my_emulated_eeprom)</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --> where:<ul>
<li>EEPROM Storage Address is an absolute address in flash where the Em_EEPROM operates. You must define the address value. Ensure the address is aligned to the size of the device's flash row and does not overlap with the memory space used by the application.</li>
<li>my_emulated_eeprom is the name of the section where the Em_EEPROM storage will be placed. The name can be changed to any name you choose.</li>
</ul>
</li>
<li>Save the changes and close the file.</li>
<li>Declare the Em_EEPROM storage in the newly created section. To do this, declare an array in flash, aligned to the size of the flash row of the device you are using. An example of such array declaration is the following: <div class="fragment"><div class="line">CY_SECTION(<span class="stringliteral">&quot;.my_emulated_eeprom&quot;</span>)</div>
<div class="line">CY_ALIGN(CY_EM_EEPROM_FLASH_SIZEOF_ROW)</div>
<div class="line">const uint8 emEepromStorage[STORAGE_SIZE];</div>
</div><!-- fragment --></li>
<li>After the Em_EEPROM storage is defined, pass the address to the middleware: <div class="fragment"><div class="line">    <span class="comment">//Old configuration</span></div>
<div class="line">    eepromConfig.<a class="code hl_variable" href="group__group__emeeprom.html#a686ebc626fadcdce3ffc40406f707f49">userFlashStartAddr</a> = (uint32_t)&amp;(emEepromStorage[0u]);</div>
<div class="line">    <span class="comment">//New configuration</span></div>
<div class="line">    eepromNewConfig.<a class="code hl_variable" href="group__group__emeeprom.html#a293c254f31fe0bd80b801c82819de60f">userNvmStartAddr</a> = (uint32_t)&amp;(emEepromStorage[0u]);</div>
</div><!-- fragment --></li>
<li>Build the project to verify the correctness of the linker control file modifications.</li>
</ol>
<h3><a class="anchor" id="section_em_eeprom_fixed_address_iar"></a>
Em_EEPROM Storage at a Fixed Address for IAR</h3>
<p >Compiler</p>
<ol type="1">
<li>Build the project to generate linker scripts.</li>
<li>Open the linker script "cy8c6xxa_cm4_dual.icf" for the CM4 core and search the following declaration: <div class="fragment"><div class="line">     <span class="stringliteral">&quot;.cy_app_signature&quot;</span> : place at address (__ICFEDIT_region_IROM1_end__ - 0x200) { section</div>
<div class="line">.cy_app_signature };</div>
</div><!-- fragment --> Paste the following code right after the declaration: <div class="fragment"><div class="line">     define symbol EM_EEPROM_START_ADDRESS = &lt;EEPROM Storage Address&gt;</div>
<div class="line">     <span class="stringliteral">&quot;.my_emulated_eeprom&quot;</span> : place at address (EM_EEPROM_START_ADDRESS) { section</div>
<div class="line">.my_emulated_eeprom };</div>
</div><!-- fragment --> Search again the following declaration: <div class="fragment"><div class="line">keep {  section .cy_m0p_image,</div>
<div class="line">        section .cy_app_signature,</div>
</div><!-- fragment --> Paste the following code right after the declaration: <div class="fragment"><div class="line">section .my_emulated_eeprom,</div>
</div><!-- fragment --> where:<ul>
<li>EEPROM Storage Address is an absolute address in flash where the Em_EEPROM operates. You must define the address value. Ensure the address is aligned to the size of the device's flash row and does not overlap with the memory space used by the application.</li>
<li>my_emulated_eeprom is the name of the section where the Em_EEPROM storage will be placed. The name can be changed to any name you choose.</li>
</ul>
</li>
<li>Save the changes and close the file.</li>
<li>Declare the Em_EEPROM storage in the newly created section. To do this, declare an array in flash, aligned to the size of the flash row of the device you are using. An example of such array declaration is the following: <div class="fragment"><div class="line">CY_SECTION(<span class="stringliteral">&quot;.my_emulated_eeprom&quot;</span>)</div>
<div class="line">CY_ALIGN(CY_EM_EEPROM_FLASH_SIZEOF_ROW)</div>
<div class="line">const uint8 emEepromStorage[STORAGE_SIZE];</div>
</div><!-- fragment --></li>
<li>After the Em_EEPROM storage is defined, pass the address to the middleware: <div class="fragment"><div class="line">    <span class="comment">//Old configuration</span></div>
<div class="line">    eepromConfig.<a class="code hl_variable" href="group__group__emeeprom.html#a686ebc626fadcdce3ffc40406f707f49">userFlashStartAddr</a> = (uint32_t)&amp;(emEepromStorage[0u]);</div>
<div class="line">    <span class="comment">//New configuration</span></div>
<div class="line">    eepromNewConfig.<a class="code hl_variable" href="group__group__emeeprom.html#a293c254f31fe0bd80b801c82819de60f">userNvmStartAddr</a> = (uint32_t)&amp;(emEepromStorage[0u]);</div>
</div><!-- fragment --></li>
<li>Build the project to verify the correctness of the linker control file modifications.</li>
</ol>
<h2><a class="anchor" id="section_em_eeprom_miscellaneous"></a>
Limitations and Restrictions</h2>
<ul>
<li>The Em_EEPROM storage location must be initialized with zeros and aligned to the flash row size referred to in the specific PSoC device datasheet otherwise the Em_EEPROM behavior may be unexpected. For convenience, CY_EM_EEPROM_FLASH_SIZEOF_ROW is provided.</li>
<li>The Em_EEPROM storage size depends on the configuration. Refer to the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_location">Em_EEPROM Storage Variable Location and Size</a> section for size calculation equations. For convenience, the CY_EM_EEPROM_GET_PHYSICAL_SIZE macro is provided.</li>
<li>Do not modify the Em_EEPROM context structure <a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a> since it may cause unexpected behavior of the Cy_Em_EEPROM functions that rely on this context structure.</li>
<li>The Internal memory address map, flash organization, size of rows, etc. is specific for each device family. Refer to the specific device datasheet for the details.</li>
<li>The Read-While-Write (RWW) feature available in PSoC 6 MCU allows you to write to flash while executing the code from flash. There are restrictions on using this feature for EEPROM emulation. There are also multiple constraints for blocking and nonblocking flash operations, relating to interrupts, Power mode, IPC usage, etc. Refer to the "Flash (Flash System Routine)" section of the CAT1 Peripheral Driver Library (mtb-pdl-cat1) API Reference Manual.<br  />
</li>
<li>Manage auxiliary flash space for both cores of PSoC 6. For PSoC 6, by default, the compiler always assigns both cores with full range of auxiliary flash (0x14000000-0x14008000) for EM_EEPROM. Both cores operate on the same flash object. A building error would occur if there is an out-sync operation on the memory range from any single core. If more than one driver and/or middleware occupying the auxiliary flash is simultaneously under used, for example, Bluetooth Low Energy (BLE) and Em_EEPROM, a building error will occur while generating the elf file. The error occurs because there is an auxiliary flash region allocated for BLE to store the Bonding list, and this region will only be allocated to the core where the BLE host lies. This out-sync between the two cores causes the building failure. For details of how to manage the auxiliary flash for both cores properly refer to the <a href="https://community.cypress.com/docs/DOC-15264"><b>Manage Flash Space for Both Cores of PSoC 6 - KBA224173</b></a></li>
<li>Writing of multiple rows by single the <a class="el" href="group__group__emeeprom.html#gaa792ff05d2b6ee71b44f1faeb2b68886" title="Writes data to a specified location.">Cy_Em_EEPROM_Write()</a> function may lead to the following behavior: The first row is written, then the device is reset due to power down or other reasons, then the device is powered up again. This leads to data integrity loss: i.e. the first row contains new data while the rest of the rows contain old data and Em_EEPROM will not be able to detect the issue since the row checksum is valid.</li>
</ul>
<h2><a class="anchor" id="section_em_eeprom_migration"></a>
Migration from PSoC Creator</h2>
<p >This section helps migrate your project from PSoC Creator with the Em_EEPROM component to ModusToolbox or other software environment using the Em_EEPROM middleware.</p>
<p >The migration consists of three steps:</p><ul>
<li><a class="el" href="group__group__emeeprom.html#section_em_eeprom_migration_location">Migration of Em_EEPROM Location</a></li>
<li><a class="el" href="group__group__emeeprom.html#section_em_eeprom_migration_configuration">Migration of Configuration</a></li>
<li><a class="el" href="group__group__emeeprom.html#section_em_eeprom_migration_function">Migration of Function</a></li>
</ul>
<h3><a class="anchor" id="section_em_eeprom_migration_location"></a>
Migration of Em_EEPROM Location</h3>
<p >The PSoC Creator Em_EEPROM component has parameter "Use Emulated EEPROM". It defines where the Em_EEPROM storage is located.</p><ul>
<li>"Use Emulated EEPROM" = No <br  />
 The Em_EEPROM storage is defined by the application program. Then move the Em_EEPROM storage declaration from the PSoC Creator project into the ModusToolbox project. Refer to <a class="el" href="group__group__emeeprom.html#section_em_eeprom_location">Em_EEPROM Storage Variable Location and Size</a> to check for other possible options.</li>
<li>"Use Emulated EEPROM" = Yes <br  />
 The Em_EEPROM component provides Em_EEPROM storage located in the auxiliary flash. The Em_EEPROM middleware requires the storage to be provided by the application program. Therefore, place the below code into your application program. <div class="fragment"><div class="line">CY_SECTION(<span class="stringliteral">&quot;.cy_em_eeprom&quot;</span>)</div>
<div class="line">CY_ALIGN(CY_EM_EEPROM_FLASH_SIZEOF_ROW)</div>
<div class="line">const uint8_t emEepromStorage[STORAGE_SIZE] = {0u};</div>
</div><!-- fragment --> where STORAGE_SIZE is the size of the storage that can be seen in the Em_EEPROM component customizer as "Actual EEPROM size (bytes)".<br  />
 For convenience, use the CY_EM_EEPROM_GET_PHYSICAL_SIZE macro to get the needed Em_EEPROM storage size depending on the configuration.</li>
</ul>
<h3><a class="anchor" id="section_em_eeprom_migration_configuration"></a>
Migration of Configuration</h3>
<p >Allocate memory for Em_EEPROM context and configuration structures, and initialize the configuration structure per the Em_EEPROM component configuration:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a> eepromContext;</div>
<div class="line"><a class="code hl_struct" href="group__group__emeeprom.html#structcy__stc__eeprom__config__t">cy_stc_eeprom_config_t</a> eepromConfig =</div>
<div class="line">{</div>
<div class="line">    .<a class="code hl_variable" href="group__group__emeeprom.html#ad41b3c5ce4619d484a648a5a4bcc0bad">eepromSize</a> = &lt;EEPROM Size&gt;,</div>
<div class="line">    .simpleMode = 0u,</div>
<div class="line">    .wearLevelingFactor = &lt;Wear Level Factor&gt;,</div>
<div class="line">    .redundantCopy = &lt;Redundant Copy&gt;,</div>
<div class="line">    .blockingWrite = &lt;Use Blocking Write&gt;,</div>
<div class="line">    .userFlashStartAddr = (uint32_t)&amp;(emEepromStorage[0u]),</div>
<div class="line">};</div>
<div class="line"><a class="code hl_struct" href="group__group__emeeprom.html#structcy__stc__eeprom__config2__t">cy_stc_eeprom_config2_t</a> eepromConfigNew =</div>
<div class="line">{</div>
<div class="line">    .<a class="code hl_variable" href="group__group__emeeprom.html#ab7fc595ca299793465899b58460c0238">eepromSize</a> = &lt;EEPROM Size&gt;,</div>
<div class="line">    .simpleMode = 0u,</div>
<div class="line">    .wearLevelingFactor = &lt;Wear Level Factor&gt;,</div>
<div class="line">    .redundantCopy = &lt;Redundant Copy&gt;,</div>
<div class="line">    .blockingWrite = &lt;Use Blocking Write&gt;,</div>
<div class="line">    .userNvmStartAddr = (uint32_t)&amp;(emEepromStorage[0u]),</div>
<div class="line">};</div>
</div><!-- fragment --><p> where the right side of initialization is the Em_EEPROM Component customizer parameters and "emEepromStorage" is the name of the storage.</p>
<h3><a class="anchor" id="section_em_eeprom_migration_function"></a>
Migration of Function</h3>
<p >Now, after the storage and configuration are defined, change the names of the functions used in the PSoC Creator project per the following table:</p>
<table class="doxtable">
<tr>
<th>PSoC Creator Em_EEPROM Component </th><th>ModusToolbox Em_EEPROM Middleware  </th></tr>
<tr>
<td>EEPROM_Init(X) </td><td>Cy_Em_EEPROM_Init(&amp;eepromConfig, &amp;eepromContext)  </td></tr>
<tr>
<td>EEPROM_Write(X1, X2, X3) </td><td>Cy_Em_EEPROM_Write(X1, X2, X3, &amp;eepromContext)  </td></tr>
<tr>
<td>EEPROM_Read(X1, X2, X3) </td><td>Cy_Em_EEPROM_Read(X1, X2, X3, &amp;eepromContext)  </td></tr>
<tr>
<td>EEPROM_Erase() </td><td>Cy_Em_EEPROM_Erase(&amp;eepromContext)  </td></tr>
<tr>
<td>EEPROM_NumWrites() </td><td>Cy_Em_EEPROM_NumWrites(&amp;eepromContext)  </td></tr>
</table>
<p ><b> Note </b> The above table shows the function names with an assumption that the PSoC Creator component name is EEPROM.</p>
<h1><a class="anchor" id="section_em_eeprom_toolchain"></a>
Supported Software and Tools</h1>
<p >This version of the Em_EEPROM Middleware was validated for the compatibility with the following software and tools:</p>
<table class="doxtable">
<tr>
<th>Software and Tools </th><th>Version  </th></tr>
<tr>
<td>ModusToolbox Software Environment </td><td>3.0  </td></tr>
<tr>
<td>CAT1 Peripheral Driver Library (mtb-pdl-cat1) </td><td>3.0.0  </td></tr>
<tr>
<td>CAT2 Peripheral Driver Library (mtb-pdl-cat2) </td><td>2.0.0  </td></tr>
<tr>
<td>GCC Compiler </td><td>10.3.1  </td></tr>
<tr>
<td>IAR Compiler </td><td>9.30.1  </td></tr>
<tr>
<td>Arm Compiler 6 </td><td>6.16  </td></tr>
<tr>
<td>Mbed OS </td><td>5.13.1  </td></tr>
<tr>
<td>FreeRTOS </td><td>10.4.3  </td></tr>
</table>
<h1><a class="anchor" id="section_em_eeprom_MISRA"></a>
MISRA-C, 2012 Compliance</h1>
<p >There are no high or medium severity compliance issues for this asset. Listed below are the deviations for minor issues.</p>
<p >The Cy_Em_EEPROM library's specific deviations:</p>
<table class="doxtable">
<tr>
<th>MISRA Rule </th><th>Rule Class (Required/Advisory) </th><th>Rule Description </th><th>Description of Deviation(s)  </th></tr>
<tr>
<td>5.9 </td><td>A </td><td>Static Identifiers should be unique. </td><td>Following naming convention for static functions.  </td></tr>
<tr>
<td>11.5 </td><td>A </td><td>Typecast of void pointer should be avoided. </td><td>The cast is used intentionally for the performance reason.  </td></tr>
</table>
<h1><a class="anchor" id="section_em_eeprom_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td rowspan="3">2.30 </td><td>The Em_EEPROM 2.30 introduces dependency to new block storage abstraction layer. This extends support to all devices that support one of the two available block storage implementation HAL NVM based and PDL based for CAT2 devices. </td><td>Easier maintainability and extendability of library for new products.  </td></tr>
<tr>
<td>Updated minor version defines </td><td>Follow naming convention  </td></tr>
<tr>
<td>Updated documentation </td><td></td></tr>
<tr>
<td rowspan="3">2.20 </td><td colspan="2">The Em_EEPROM 2.20 adds support for XMC 7xxx and T2G-B-H devices.   </td></tr>
<tr>
<td>Updated major and minor version defines </td><td>Follow naming convention  </td></tr>
<tr>
<td>Updated documentation </td><td></td></tr>
<tr>
<td rowspan="4">2.10 </td><td colspan="2">The Em_EEPROM 2.10 adds support for PSoC 4 devices.   </td></tr>
<tr>
<td>Updated major and minor version defines </td><td>Follow naming convention  </td></tr>
<tr>
<td>Updated documentation </td><td>User experience improvement and Logo update  </td></tr>
<tr>
<td>Fixed MISRA violations </td><td>Improved the middleware robustness  </td></tr>
<tr>
<td rowspan="10">2.00 </td><td colspan="2">The Em_EEPROM 2.0 is not backward compatible with the previous version. It was significantly rewritten with changing the behavior of operation, adding many improvements and fixing defects.<br  />
 However, the application programming interface (API) contains only single change and you can seamlessly migrate to 2.0 version. This change is consist in adding the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_mode_simple">Simple Mode</a>.   </td></tr>
<tr>
<td>Updated major and minor version defines </td><td>Follow naming convention  </td></tr>
<tr>
<td>Updated documentation </td><td>User experience improvement  </td></tr>
<tr>
<td>Changed the CY_EM_EEPROM_EEPROM_DATA_LEN macro by adding the simpleMode parameter </td><td>Added new mode when wear leveling and redundant copy features are disabled  </td></tr>
<tr>
<td>Fixed MISRA violations </td><td>Improved the middleware robustness  </td></tr>
<tr>
<td>Fixed the defect of the <a class="el" href="group__group__emeeprom.html#ga9e14084e3054f6f147004d2914f9216d" title="Reads data from a specified location.">Cy_Em_EEPROM_Read()</a> function when Emulated EEPROM data corruption in some cases caused infinite loop </td><td>Fixed Defect  </td></tr>
<tr>
<td>Fixed the defect of the <a class="el" href="group__group__emeeprom.html#ga9e14084e3054f6f147004d2914f9216d" title="Reads data from a specified location.">Cy_Em_EEPROM_Read()</a> function when the function returns incorrect data after restoring data from the redundant copy </td><td>Fixed Defect  </td></tr>
<tr>
<td>Added the mechanism to restore the corrupted redundant copy from the main data copy </td><td>Improved the Em_EEPROM data reliability  </td></tr>
<tr>
<td>Revised the operation of <a class="el" href="group__group__emeeprom.html#ga9e14084e3054f6f147004d2914f9216d" title="Reads data from a specified location.">Cy_Em_EEPROM_Read()</a> and <a class="el" href="group__group__emeeprom.html#gab9f608d788f1a854b10c652c3bb00fdd" title="This function was the entry point up until version 2.20.">Cy_Em_EEPROM_Init()</a> functions by removing the write operation. </td><td>Improved the Em_EEPROM functionality  </td></tr>
<tr>
<td>Expanded the checksum verification to the entire row. </td><td>Improved the Em_EEPROM data reliability  </td></tr>
<tr>
<td>1.10 </td><td>Flattened the organization of the driver source code into a single source directory and a single include directory  </td><td>Simplified the Driver library directory-structure  </td></tr>
<tr>
<td>1.0.1 </td><td>Added the Em_EEPROM storage allocation note to the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_configuration_considerations">Configuration Considerations</a> </td><td>Documentation update and clarification  </td></tr>
<tr>
<td>1.0 </td><td>Initial Version </td><td></td></tr>
</table>
<h1><a class="anchor" id="section_em_eeprom_more_information"></a>
More Information</h1>
<p >For more information, refer to the following documents:</p>
<ul>
<li><a href="https://www.cypress.com/products/modustoolbox-software-environment"><b>ModusToolbox Software Environment, Quick Start Guide, Documentation, and Videos</b> </a></li>
<li><a href="https://www.cypress.com/an219434"><b>AN219434 Importing PSoC Creator Code into an IDE for a PSoC 6 Project</b> </a></li>
<li><a href="http://www.cypress.com/an210781"><b>AN210781 Getting Started with PSoC 6 MCU with Bluetooth Low Energy (BLE) Connectivity</b> </a></li>
<li><a href="https://cypresssemiconductorco.github.io/mtb-pdl-cat1/pdl_api_reference_manual/html/index.html"><b>CAT1 PDL API Reference</b></a></li>
<li><a href="https://cypresssemiconductorco.github.io/mtb-pdl-cat2/pdl_api_reference_manual/html/index.html"><b>CAT2 PDL API Reference</b></a></li>
<li><a href="https://www.cypress.com/documentation/technical-reference-manuals/psoc-6-mcu-psoc-63-ble-architecture-technical-reference"><b>PSoC 6 Technical Reference Manual</b> </a></li>
<li><a href="http://www.cypress.com/ds218787"><b>PSoC 63 with BLE Datasheet Programmable System-on-Chip datasheet</b> </a></li>
<li><a href="http://www.cypress.com/psoc4"><b>PSoC 4 Product Reference</b> </a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The links to the other software component's documentation (middleware and PDL) point to GitHub to the latest available version of the software. To get documentation of the specified version, download from GitHub and unzip the component archive. The documentation is available in the <em>docs</em> folder. </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structcy__stc__eeprom__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__config__t">cy_stc_eeprom_config_t</a></td></tr>
<tr class="memdesc:structcy__stc__eeprom__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Em_EEPROM configuration structure.  <a href="group__group__emeeprom.html#structcy__stc__eeprom__config__t">More...</a><br /></td></tr>
<tr class="separator:structcy__stc__eeprom__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structcy__stc__eeprom__config2__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__config2__t">cy_stc_eeprom_config2_t</a></td></tr>
<tr class="memdesc:structcy__stc__eeprom__config2__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Em_EEPROM new configuration structure.  <a href="group__group__emeeprom.html#structcy__stc__eeprom__config2__t">More...</a><br /></td></tr>
<tr class="separator:structcy__stc__eeprom__config2__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structcy__stc__eeprom__context__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a></td></tr>
<tr class="memdesc:structcy__stc__eeprom__context__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Em_EEPROM context data structure.  <a href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">More...</a><br /></td></tr>
<tr class="separator:structcy__stc__eeprom__context__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5ccc968f70960578a9237d12f9c667b4"><td class="memItemLeft" align="right" valign="top"><a id="ga5ccc968f70960578a9237d12f9c667b4" name="ga5ccc968f70960578a9237d12f9c667b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MTB_EM_EEPROM_BAD_PARAM</b>&#160;&#160;&#160;    CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_MIDDLEWARE_EM_EEPROM, 0)</td></tr>
<tr class="memdesc:ga5ccc968f70960578a9237d12f9c667b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An invalid parameter value is passed in. <br /></td></tr>
<tr class="separator:ga5ccc968f70960578a9237d12f9c667b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71208887512ec1c7a317ed8b076cebcf"><td class="memItemLeft" align="right" valign="top"><a id="ga71208887512ec1c7a317ed8b076cebcf" name="ga71208887512ec1c7a317ed8b076cebcf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MTB_EM_EEPROM_BAD_CHECKSUM</b>&#160;&#160;&#160;    CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_MIDDLEWARE_EM_EEPROM, 1)</td></tr>
<tr class="memdesc:ga71208887512ec1c7a317ed8b076cebcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data in EM_EEPROM is corrupted, the checksum failed. <br /></td></tr>
<tr class="separator:ga71208887512ec1c7a317ed8b076cebcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96154062335a8c160233e08297bb43f5"><td class="memItemLeft" align="right" valign="top"><a id="ga96154062335a8c160233e08297bb43f5" name="ga96154062335a8c160233e08297bb43f5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MTB_EM_EEPROM_BAD_DATA</b>&#160;&#160;&#160;    CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_MIDDLEWARE_EM_EEPROM, 2)</td></tr>
<tr class="memdesc:ga96154062335a8c160233e08297bb43f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The provided configuration is invalid or placing Em_EEPROM in NVM failed. <br /></td></tr>
<tr class="separator:ga96154062335a8c160233e08297bb43f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac570deb62e8e36d2c307581a2b9ead53"><td class="memItemLeft" align="right" valign="top"><a id="gac570deb62e8e36d2c307581a2b9ead53" name="gac570deb62e8e36d2c307581a2b9ead53"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MTB_EM_EEPROM_WRITE_FAIL</b>&#160;&#160;&#160;    CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_MIDDLEWARE_EM_EEPROM, 3)</td></tr>
<tr class="memdesc:gac570deb62e8e36d2c307581a2b9ead53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to Em_EEPROM failed. <br /></td></tr>
<tr class="separator:gac570deb62e8e36d2c307581a2b9ead53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fd059d7ba56ec03d88d65a7e5c79c81"><td class="memItemLeft" align="right" valign="top"><a id="ga6fd059d7ba56ec03d88d65a7e5c79c81" name="ga6fd059d7ba56ec03d88d65a7e5c79c81"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MTB_EM_EEPROM_REDUNDANT_COPY_USED</b>&#160;&#160;&#160;    CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_MIDDLEWARE_EM_EEPROM, 4)</td></tr>
<tr class="memdesc:ga6fd059d7ba56ec03d88d65a7e5c79c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">When redundant copy is enabled and one of the copies has bad CRC and other one valid CRC. <br /></td></tr>
<tr class="separator:ga6fd059d7ba56ec03d88d65a7e5c79c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0bf9bfb139a2298c6178b8e801c9614"><td class="memItemLeft" align="right" valign="top"><a id="gab0bf9bfb139a2298c6178b8e801c9614" name="gab0bf9bfb139a2298c6178b8e801c9614"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CY_EM_EEPROM_MW_VERSION_MAJOR</b>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:gab0bf9bfb139a2298c6178b8e801c9614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Library major version. <br /></td></tr>
<tr class="separator:gab0bf9bfb139a2298c6178b8e801c9614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15ba88c4930fbc76af0863e9aa2c7ece"><td class="memItemLeft" align="right" valign="top"><a id="ga15ba88c4930fbc76af0863e9aa2c7ece" name="ga15ba88c4930fbc76af0863e9aa2c7ece"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CY_EM_EEPROM_MW_VERSION_MINOR</b>&#160;&#160;&#160;(30)</td></tr>
<tr class="memdesc:ga15ba88c4930fbc76af0863e9aa2c7ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Library minor version. <br /></td></tr>
<tr class="separator:ga15ba88c4930fbc76af0863e9aa2c7ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga00cb0e6ed68329cd7aba18e3a93e13d2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__emeeprom.html#ga00cb0e6ed68329cd7aba18e3a93e13d2">cy_en_em_eeprom_status_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__emeeprom.html#gga00cb0e6ed68329cd7aba18e3a93e13d2a76c897909d04df4dcbe9a901aa3a0fde">CY_EM_EEPROM_SUCCESS</a> = 0x00uL
, <br />
&#160;&#160;<a class="el" href="group__group__emeeprom.html#gga00cb0e6ed68329cd7aba18e3a93e13d2a3a60e8bda0d0f453015522f1aa761956">CY_EM_EEPROM_BAD_PARAM</a> = MTB_EM_EEPROM_BAD_PARAM
, <br />
&#160;&#160;<a class="el" href="group__group__emeeprom.html#gga00cb0e6ed68329cd7aba18e3a93e13d2a303428d654a6313bfac66e56d7e3dd4d">CY_EM_EEPROM_BAD_CHECKSUM</a> = MTB_EM_EEPROM_BAD_CHECKSUM
, <br />
&#160;&#160;<a class="el" href="group__group__emeeprom.html#gga00cb0e6ed68329cd7aba18e3a93e13d2a16252cb6d3b9e7318d4e4935005e7f59">CY_EM_EEPROM_BAD_DATA</a> = MTB_EM_EEPROM_BAD_DATA
, <br />
&#160;&#160;<a class="el" href="group__group__emeeprom.html#gga00cb0e6ed68329cd7aba18e3a93e13d2a76c360c7a3688c44efd2d5ab46814cd3">CY_EM_EEPROM_WRITE_FAIL</a> = MTB_EM_EEPROM_WRITE_FAIL
, <br />
&#160;&#160;<a class="el" href="group__group__emeeprom.html#gga00cb0e6ed68329cd7aba18e3a93e13d2a88d2e935967ca619987c78a194bbca5e">CY_EM_EEPROM_REDUNDANT_COPY_USED</a> = MTB_EM_EEPROM_REDUNDANT_COPY_USED
<br />
 }</td></tr>
<tr class="memdesc:ga00cb0e6ed68329cd7aba18e3a93e13d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Em_EEPROM return enumeration type.  <a href="group__group__emeeprom.html#ga00cb0e6ed68329cd7aba18e3a93e13d2">More...</a><br /></td></tr>
<tr class="separator:ga00cb0e6ed68329cd7aba18e3a93e13d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4002a38fb2fd80487dc58eb4518a471f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__emeeprom.html#ga00cb0e6ed68329cd7aba18e3a93e13d2">cy_en_em_eeprom_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__emeeprom.html#ga4002a38fb2fd80487dc58eb4518a471f">Cy_Em_EEPROM_Init_BD</a> (const <a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__config2__t">cy_stc_eeprom_config2_t</a> *config, <a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a> *context, mtb_block_storage_t *block_device)</td></tr>
<tr class="memdesc:ga4002a38fb2fd80487dc58eb4518a471f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the Emulated EEPROM library by filling the context structure.  <a href="group__group__emeeprom.html#ga4002a38fb2fd80487dc58eb4518a471f">More...</a><br /></td></tr>
<tr class="separator:ga4002a38fb2fd80487dc58eb4518a471f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9f608d788f1a854b10c652c3bb00fdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__emeeprom.html#ga00cb0e6ed68329cd7aba18e3a93e13d2">cy_en_em_eeprom_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__emeeprom.html#gab9f608d788f1a854b10c652c3bb00fdd">Cy_Em_EEPROM_Init</a> (const <a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__config__t">cy_stc_eeprom_config_t</a> *config, <a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a> *context)</td></tr>
<tr class="memdesc:gab9f608d788f1a854b10c652c3bb00fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function was the entry point up until version 2.20.  <a href="group__group__emeeprom.html#gab9f608d788f1a854b10c652c3bb00fdd">More...</a><br /></td></tr>
<tr class="separator:gab9f608d788f1a854b10c652c3bb00fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e14084e3054f6f147004d2914f9216d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__emeeprom.html#ga00cb0e6ed68329cd7aba18e3a93e13d2">cy_en_em_eeprom_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__emeeprom.html#ga9e14084e3054f6f147004d2914f9216d">Cy_Em_EEPROM_Read</a> (uint32_t addr, void *eepromData, uint32_t size, <a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a> *context)</td></tr>
<tr class="memdesc:ga9e14084e3054f6f147004d2914f9216d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from a specified location.  <a href="group__group__emeeprom.html#ga9e14084e3054f6f147004d2914f9216d">More...</a><br /></td></tr>
<tr class="separator:ga9e14084e3054f6f147004d2914f9216d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa792ff05d2b6ee71b44f1faeb2b68886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__emeeprom.html#ga00cb0e6ed68329cd7aba18e3a93e13d2">cy_en_em_eeprom_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__emeeprom.html#gaa792ff05d2b6ee71b44f1faeb2b68886">Cy_Em_EEPROM_Write</a> (uint32_t addr, const void *eepromData, uint32_t size, <a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a> *context)</td></tr>
<tr class="memdesc:gaa792ff05d2b6ee71b44f1faeb2b68886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to a specified location.  <a href="group__group__emeeprom.html#gaa792ff05d2b6ee71b44f1faeb2b68886">More...</a><br /></td></tr>
<tr class="separator:gaa792ff05d2b6ee71b44f1faeb2b68886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad61dbc3c01d2bbf96e0c0d5b6d2e0b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__emeeprom.html#ga00cb0e6ed68329cd7aba18e3a93e13d2">cy_en_em_eeprom_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__emeeprom.html#gad61dbc3c01d2bbf96e0c0d5b6d2e0b61">Cy_Em_EEPROM_Erase</a> (<a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a> *context)</td></tr>
<tr class="memdesc:gad61dbc3c01d2bbf96e0c0d5b6d2e0b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function erases the entire content of Em_EEPROM.  <a href="group__group__emeeprom.html#gad61dbc3c01d2bbf96e0c0d5b6d2e0b61">More...</a><br /></td></tr>
<tr class="separator:gad61dbc3c01d2bbf96e0c0d5b6d2e0b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7fb39640526ce706a7867d955d2b275"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__emeeprom.html#gad7fb39640526ce706a7867d955d2b275">Cy_Em_EEPROM_NumWrites</a> (<a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a> *context)</td></tr>
<tr class="memdesc:gad7fb39640526ce706a7867d955d2b275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the Em_EEPROM Writes completed so far.  <a href="group__group__emeeprom.html#gad7fb39640526ce706a7867d955d2b275">More...</a><br /></td></tr>
<tr class="separator:gad7fb39640526ce706a7867d955d2b275"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structcy__stc__eeprom__config__t" id="structcy__stc__eeprom__config__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structcy__stc__eeprom__config__t">&#9670;&nbsp;</a></span>cy_stc_eeprom_config_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct cy_stc_eeprom_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ad41b3c5ce4619d484a648a5a4bcc0bad" name="ad41b3c5ce4619d484a648a5a4bcc0bad"></a>uint32_t</td>
<td class="fieldname">
eepromSize</td>
<td class="fielddoc">
The logical size of data in bytes to store in the Em_EEPROM. <p >The size is rounded up to a full Em_EEPROM row size physically. The row size is specific for a device family. Refer to the specific PSoC device datasheet.<br  />
 Note this size is often smaller than the total amount of nvm used for the Em_EEPROM storage. The Em_EEPROM storage size depends on the Em_EEPROM configuration and can be bigger because increasing nvm endurance (wear-leveling) and restoring corrupted data from a redundant copy. Refer to the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_location">Em_EEPROM Storage Variable Location and Size</a> section for size calculation equations. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa54a301d7a69d9a65a07b02c049665e4" name="aa54a301d7a69d9a65a07b02c049665e4"></a>uint8_t</td>
<td class="fieldname">
simpleMode</td>
<td class="fielddoc">
Simple mode, when enabled (1 - enabled, 0 - disabled), means no additional service information is stored by the Em_EEPROM middleware like checksums, headers, a number of writes, etc. <p >Data is stored directly by the specified address. The size of Em_EEPROM storage is equal to the number of byte specified in the eepromSize parameter rounded up to a full row size. The wear leveling and redundant copy features are disabled, i.e. wearLevelingFactor and redundantCopy parameters are ignored. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a346d69ec432c3cfe21253f2a46e3cda6" name="a346d69ec432c3cfe21253f2a46e3cda6"></a>uint8_t</td>
<td class="fieldname">
wearLevelingFactor</td>
<td class="fielddoc">
The higher the factor is, the more nvm is used, but a higher number of erase/write cycles can be done on Em_EEPROM. <p >Multiply this number by the datasheet write endurance spec to determine the max of write cycles.<br  />
 The amount of wear leveling from 1 to 10. 1 means no wear leveling is used. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad6d96546ec661d1600f92bbeb9f3fb5d" name="ad6d96546ec661d1600f92bbeb9f3fb5d"></a>uint8_t</td>
<td class="fieldname">
redundantCopy</td>
<td class="fielddoc">
If enabled (1 - enabled, 0 - disabled), a checksum (stored in a row) is calculated on each row of data, while a redundant copy of Em_EEPROM is stored in another location. <p >When data is read, first the checksum is checked. If that checksum is bad, and the redundant copy's checksum is good, the copy is restored. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a8f6acdb1ccef76931219fdf19032188d" name="a8f6acdb1ccef76931219fdf19032188d"></a>uint8_t</td>
<td class="fieldname">
blockingWrite</td>
<td class="fielddoc">
If enabled (1 - enabled, 0 - disabled), the blocking writes to nvm are used in the design. <p >Otherwise, non-blocking nvm writes are used. From the user's perspective, the behavior of blocking and non-blocking writes are the same - the difference is that the non-blocking writes do not block the interrupts.</p>
<dl class="section note"><dt>Note</dt><dd>Non-blocking nvm write is only supported by PSoC 6. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a686ebc626fadcdce3ffc40406f707f49" name="a686ebc626fadcdce3ffc40406f707f49"></a>uint32_t</td>
<td class="fieldname">
userFlashStartAddr</td>
<td class="fielddoc">
The address of the nvm storage. <p >The storage start address is filled to the Emulated EEPROM configuration structure and then the structure is passed to the <a class="el" href="group__group__emeeprom.html#gab9f608d788f1a854b10c652c3bb00fdd" title="This function was the entry point up until version 2.20.">Cy_Em_EEPROM_Init()</a> function. </p>
</td></tr>
</table>

</div>
</div>
<a name="structcy__stc__eeprom__config2__t" id="structcy__stc__eeprom__config2__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structcy__stc__eeprom__config2__t">&#9670;&nbsp;</a></span>cy_stc_eeprom_config2_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct cy_stc_eeprom_config2_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ab7fc595ca299793465899b58460c0238" name="ab7fc595ca299793465899b58460c0238"></a>uint32_t</td>
<td class="fieldname">
eepromSize</td>
<td class="fielddoc">
The logical size of data in bytes to store in the Em_EEPROM. <p >The size is rounded up to a full Em_EEPROM row size physically. The row size is specific for a device family. Refer to the specific PSoC device datasheet.<br  />
 Note this size is often smaller than the total amount of nvm used for the Em_EEPROM storage. The Em_EEPROM storage size depends on the Em_EEPROM configuration and can be bigger because increasing nvm endurance (wear-leveling) and restoring corrupted data from a redundant copy. Refer to the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_location">Em_EEPROM Storage Variable Location and Size</a> section for size calculation equations. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa7903f98a2d4dc8c482f7fefdbd40a56" name="aa7903f98a2d4dc8c482f7fefdbd40a56"></a>uint8_t</td>
<td class="fieldname">
simpleMode</td>
<td class="fielddoc">
Simple mode, when enabled (1 - enabled, 0 - disabled), means no additional service information is stored by the Em_EEPROM middleware like checksums, headers, a number of writes, etc. <p >Data is stored directly by the specified address. The size of Em_EEPROM storage is equal to the number of byte specified in the eepromSize parameter rounded up to a full row size. The wear leveling and redundant copy features are disabled, i.e. wearLevelingFactor and redundantCopy parameters are ignored. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a261b17885980cf13747396144534cc6d" name="a261b17885980cf13747396144534cc6d"></a>uint8_t</td>
<td class="fieldname">
wearLevelingFactor</td>
<td class="fielddoc">
The higher the factor is, the more nvm is used, but a higher number of erase/write cycles can be done on Em_EEPROM. <p >Multiply this number by the datasheet write endurance spec to determine the max of write cycles.<br  />
 The amount of wear leveling from 1 to 10. 1 means no wear leveling is used. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aea72b9f261544856bb8b3be7760f4833" name="aea72b9f261544856bb8b3be7760f4833"></a>uint8_t</td>
<td class="fieldname">
redundantCopy</td>
<td class="fielddoc">
If enabled (1 - enabled, 0 - disabled), a checksum (stored in a row) is calculated on each row of data, while a redundant copy of Em_EEPROM is stored in another location. <p >When data is read, first the checksum is checked. If that checksum is bad, and the redundant copy's checksum is good, the copy is restored. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a40abb446ac02795d5803af40fbc3642f" name="a40abb446ac02795d5803af40fbc3642f"></a>uint8_t</td>
<td class="fieldname">
blockingWrite</td>
<td class="fielddoc">
If enabled (1 - enabled, 0 - disabled), the blocking writes to nvm are used in the design. <p >Otherwise, non-blocking nvm writes are used. From the user's perspective, the behavior of blocking and non-blocking writes are the same - the difference is that the non-blocking writes do not block the interrupts.</p>
<dl class="section note"><dt>Note</dt><dd>Non-blocking nvm write is only supported by PSoC 6. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a293c254f31fe0bd80b801c82819de60f" name="a293c254f31fe0bd80b801c82819de60f"></a>uint32_t</td>
<td class="fieldname">
userNvmStartAddr</td>
<td class="fielddoc">
The address of the nvm storage. <p >The storage start address is filled to the Emulated EEPROM configuration structure and then the structure is passed to the <a class="el" href="group__group__emeeprom.html#gab9f608d788f1a854b10c652c3bb00fdd" title="This function was the entry point up until version 2.20.">Cy_Em_EEPROM_Init()</a> function. </p>
</td></tr>
</table>

</div>
</div>
<a name="structcy__stc__eeprom__context__t" id="structcy__stc__eeprom__context__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structcy__stc__eeprom__context__t">&#9670;&nbsp;</a></span>cy_stc_eeprom_context_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct cy_stc_eeprom_context_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ae36a1dffdb6999d0da9f763041c3ca78" name="ae36a1dffdb6999d0da9f763041c3ca78"></a>uint16_t</td>
<td class="fieldname">
numberOfRows</td>
<td class="fielddoc">
The number of nvm rows allocated for the Em_EEPROM excluding the number of rows allocated for wear-leveling and a redundant copy overhead. </td></tr>
<tr><td class="fieldtype">
<a id="a9fc76f95ee987ca778dd4dede367ec12" name="a9fc76f95ee987ca778dd4dede367ec12"></a>uint16_t</td>
<td class="fieldname">
rowSize</td>
<td class="fielddoc">
The size of a EEPROM row in bytes, equal to the program size of the NVM or a multiple of it that is &gt;= than CY_EM_EEPROM_MINIMUM_ROW_SIZE for devices whose program size is too small. </td></tr>
<tr><td class="fieldtype">
<a id="a1136c1032e20149af06f0763849211d9" name="a1136c1032e20149af06f0763849211d9"></a>uint32_t</td>
<td class="fieldname">
eepromSize</td>
<td class="fielddoc">
The number of bytes to store in Em_EEPROM. </td></tr>
<tr><td class="fieldtype">
<a id="a73845ac1bd1d2c5b4eafd9efc86f7fa9" name="a73845ac1bd1d2c5b4eafd9efc86f7fa9"></a>uint8_t</td>
<td class="fieldname">
wearLevelingFactor</td>
<td class="fielddoc">
The amount of wear leveling from 1 to 10. <p >1 means no wear leveling is used. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a8568bff10b78e3b1171a774501d87d1d" name="a8568bff10b78e3b1171a774501d87d1d"></a>uint8_t</td>
<td class="fieldname">
simpleMode</td>
<td class="fielddoc">
No headers configured. </td></tr>
<tr><td class="fieldtype">
<a id="a9930dd5410628e79f68927cd30bca6d3" name="a9930dd5410628e79f68927cd30bca6d3"></a>uint8_t</td>
<td class="fieldname">
redundantCopy</td>
<td class="fielddoc">
If not zero, a redundant copy of the Em_EEPROM is included. </td></tr>
<tr><td class="fieldtype">
<a id="a662b2e5e86183706701aa79280dca36d" name="a662b2e5e86183706701aa79280dca36d"></a>uint8_t</td>
<td class="fieldname">
blockingWrite</td>
<td class="fielddoc">
If not zero, a blocking write to nvm is used. <p >Otherwise, a non-blocking write is used. This parameter is used only for PSoC 6. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa5a0697020826e5401a694f2c6ec811e" name="aa5a0697020826e5401a694f2c6ec811e"></a>uint32_t</td>
<td class="fieldname">
userNvmStartAddr</td>
<td class="fielddoc">
The start address for the Em_EEPROM memory in nvm. </td></tr>
<tr><td class="fieldtype">
<a id="aa9ff93ec39e0c9671463576e87de6c05" name="aa9ff93ec39e0c9671463576e87de6c05"></a>uint16_t</td>
<td class="fieldname">
byteInRow</td>
<td class="fielddoc">
The number of user's data bytes in one row for non simple mode. <p >It is equal to half the row size as in non simple mode half of the row is reserved for the headers data portion and the other half is reserved for the actual user's data. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afde80fb70ca1b9c035d183b7359a57b6" name="afde80fb70ca1b9c035d183b7359a57b6"></a>uint16_t</td>
<td class="fieldname">
headerDataLength</td>
<td class="fielddoc">
Defines the length of data that can be stored in the Em_EEPROM header. </td></tr>
<tr><td class="fieldtype">
<a id="a29be33dbb9a3ea5e901c1b912b34f443" name="a29be33dbb9a3ea5e901c1b912b34f443"></a>uint32_t *</td>
<td class="fieldname">
ptrLastWrittenRow</td>
<td class="fielddoc">
The pointer to the last written row. </td></tr>
<tr><td class="fieldtype">
<a id="aa463a9bd9675271cf53ed166cdf24a1a" name="aa463a9bd9675271cf53ed166cdf24a1a"></a>const mtb_block_storage_t *</td>
<td class="fieldname">
bd</td>
<td class="fielddoc">
The block storage object holding the information on prototypes for the necessary operations. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga00cb0e6ed68329cd7aba18e3a93e13d2" name="ga00cb0e6ed68329cd7aba18e3a93e13d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00cb0e6ed68329cd7aba18e3a93e13d2">&#9670;&nbsp;</a></span>cy_en_em_eeprom_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__emeeprom.html#ga00cb0e6ed68329cd7aba18e3a93e13d2">cy_en_em_eeprom_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Em_EEPROM return enumeration type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga00cb0e6ed68329cd7aba18e3a93e13d2a76c897909d04df4dcbe9a901aa3a0fde" name="gga00cb0e6ed68329cd7aba18e3a93e13d2a76c897909d04df4dcbe9a901aa3a0fde"></a>CY_EM_EEPROM_SUCCESS&#160;</td><td class="fielddoc"><p >The operation executed successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga00cb0e6ed68329cd7aba18e3a93e13d2a3a60e8bda0d0f453015522f1aa761956" name="gga00cb0e6ed68329cd7aba18e3a93e13d2a3a60e8bda0d0f453015522f1aa761956"></a>CY_EM_EEPROM_BAD_PARAM&#160;</td><td class="fielddoc"><p >An invalid parameter value is passed in. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga00cb0e6ed68329cd7aba18e3a93e13d2a303428d654a6313bfac66e56d7e3dd4d" name="gga00cb0e6ed68329cd7aba18e3a93e13d2a303428d654a6313bfac66e56d7e3dd4d"></a>CY_EM_EEPROM_BAD_CHECKSUM&#160;</td><td class="fielddoc"><p >The data in EM_EEPROM is corrupted, the checksum failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga00cb0e6ed68329cd7aba18e3a93e13d2a16252cb6d3b9e7318d4e4935005e7f59" name="gga00cb0e6ed68329cd7aba18e3a93e13d2a16252cb6d3b9e7318d4e4935005e7f59"></a>CY_EM_EEPROM_BAD_DATA&#160;</td><td class="fielddoc"><p >The provided configuration is invalid or placing Em_EEPROM in NVM failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga00cb0e6ed68329cd7aba18e3a93e13d2a76c360c7a3688c44efd2d5ab46814cd3" name="gga00cb0e6ed68329cd7aba18e3a93e13d2a76c360c7a3688c44efd2d5ab46814cd3"></a>CY_EM_EEPROM_WRITE_FAIL&#160;</td><td class="fielddoc"><p >Write to Em_EEPROM failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga00cb0e6ed68329cd7aba18e3a93e13d2a88d2e935967ca619987c78a194bbca5e" name="gga00cb0e6ed68329cd7aba18e3a93e13d2a88d2e935967ca619987c78a194bbca5e"></a>CY_EM_EEPROM_REDUNDANT_COPY_USED&#160;</td><td class="fielddoc"><p >When redundant copy is enabled and one of the copies has bad CRC and other one valid CRC. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4002a38fb2fd80487dc58eb4518a471f" name="ga4002a38fb2fd80487dc58eb4518a471f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4002a38fb2fd80487dc58eb4518a471f">&#9670;&nbsp;</a></span>Cy_Em_EEPROM_Init_BD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__emeeprom.html#ga00cb0e6ed68329cd7aba18e3a93e13d2">cy_en_em_eeprom_status_t</a> Cy_Em_EEPROM_Init_BD </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__config2__t">cy_stc_eeprom_config2_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mtb_block_storage_t *&#160;</td>
          <td class="paramname"><em>block_device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the Emulated EEPROM library by filling the context structure. </p>
<p >This function is called by the application program prior to calling any other function of the Em_EEPROM middleware.</p>
<p >Do not modify the context structure after it is filled with this function. Modification of the context structure may cause unexpected behavior of the Cy_Em_EEPROM functions that rely on this context structure.</p>
<p >This function does the following:</p><ol type="1">
<li>Checks the provided configuration for correctness.</li>
<li>Copies the provided configuration into the context structure.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>The pointer to the configuration structure Configuration to use to initialize the em_eeprom object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>Pointer to a em_eeprom object. The caller must allocate the memory for this object but the init function will initialize its contents. The pointer to the Em_EEPROM context structure to be filled by the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_device</td><td>Block device interface for the underlying memory to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the initialization operation.<ul>
<li>CY_RSLT_SUCCESS - The operation is successfully completed.</li>
<li>MTB_EM_EEPROM_BAD_PARAM - The input parameter is invalid.</li>
<li>MTB_EM_EEPROM_BAD_DATA - The configuration is incorrect. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab9f608d788f1a854b10c652c3bb00fdd" name="gab9f608d788f1a854b10c652c3bb00fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9f608d788f1a854b10c652c3bb00fdd">&#9670;&nbsp;</a></span>Cy_Em_EEPROM_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__emeeprom.html#ga00cb0e6ed68329cd7aba18e3a93e13d2">cy_en_em_eeprom_status_t</a> Cy_Em_EEPROM_Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__config__t">cy_stc_eeprom_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function was the entry point up until version 2.20. </p>
<p >All devices supported (PSOC6 based devices, PSOC4 based devices, XMC7xxx and T2G-B-H based devices) will continue to work as expected when using this function, however it still introduces a distinction between memory architectures that should not be a concern for the Em_EEPROM library Users should start using Cy_Em_EEPROM_Init_BD instead by defining a block storage device beforehand. Using this function on version 2.30 onwards will imply that all devices use block storage implementation based on cyhal_nvm except for cat2 devices which will use block storage implementation specific to cat2 devices. This function is kept for backwards compatibility.</p>
<p >Initializes the Emulated EEPROM library by filling the context structure.</p>
<p >This function is called by the application program prior to calling any other function of the Em_EEPROM middleware.</p>
<p >This function does the following:</p><ol type="1">
<li>Selects the appropriate block storage solution based on the DUT</li>
<li>Calls Cy_Em_EEPROM_Init_BD</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>The pointer to the configuration structure Configuration to use to initialize the em_eeprom object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>Pointer to a em_eeprom object. The caller must allocate the memory for this object but the init function will initialize its contents. The pointer to the Em_EEPROM context structure to be filled by the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the initialization operation.<ul>
<li>CY_RSLT_SUCCESS - The operation is successfully completed.</li>
<li>MTB_EM_EEPROM_BAD_PARAM - The input parameter is invalid.</li>
<li>MTB_EM_EEPROM_BAD_DATA - The configuration is incorrect. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9e14084e3054f6f147004d2914f9216d" name="ga9e14084e3054f6f147004d2914f9216d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e14084e3054f6f147004d2914f9216d">&#9670;&nbsp;</a></span>Cy_Em_EEPROM_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__emeeprom.html#ga00cb0e6ed68329cd7aba18e3a93e13d2">cy_en_em_eeprom_status_t</a> Cy_Em_EEPROM_Read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>eepromData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data from a specified location. </p>
<p >This function takes a logical Em_EEPROM address, converts it to an actual physical address where data is stored and returns the data to the user.</p>
<p >This function uses a buffer of the flash row size to perform the read operation. For the size of the row, refer to the specific PSoC device datasheet.</p>
<p >There are restrictions on using the read-while-write (RWW) feature for EEPROM emulation. There are also multiple constraints for blocking and nonblocking flash operations, relating to interrupts, power modes, IPC usage, etc. Refer to the "Flash (Flash System Routine)" section of the CAT1 Peripheral Driver Library (mtb-pdl-cat1) API Reference Manual.<br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The logical start address in the Em_EEPROM storage to start reading data from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eepromData</td><td>The pointer to a user array to write data to. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>The amount of data to read in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to a em_eeprom object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the read operation.<ul>
<li>CY_RSLT_SUCCESS - The operation is successfully completed.</li>
<li>MTB_EM_EEPROM_BAD_CHECKSUM - One of the row the data read from contains bad checksum.</li>
<li>MTB_EM_EEPROM_REDUNDANT_COPY_USED - Some data were read from redundant copy.</li>
<li>MTB_EM_EEPROM_BAD_PARAM - The function input parameter is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa792ff05d2b6ee71b44f1faeb2b68886" name="gaa792ff05d2b6ee71b44f1faeb2b68886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa792ff05d2b6ee71b44f1faeb2b68886">&#9670;&nbsp;</a></span>Cy_Em_EEPROM_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__emeeprom.html#ga00cb0e6ed68329cd7aba18e3a93e13d2">cy_en_em_eeprom_status_t</a> Cy_Em_EEPROM_Write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>eepromData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data to a specified location. </p>
<p >This function takes the logical Em_EEPROM address and converts it to an actual physical address and writes data there. If wear leveling is enabled, the writing process uses the wear leveling techniques.</p>
<p >This is a blocking function and it does not return until the write operation is completed. The user's application program cannot enter Hibernate mode until the write is completed. The write operation is allowed in CPU Sleep mode. Do not reset your device during the flash operation, including the XRES pin, a software reset, and watchdog reset sources. Also, configure low-voltage detect circuits to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.</p>
<p >This function uses a buffer of the row size to perform the write operation. All write operations are done for row size. For the size of the row, refer to the specific device datasheet.</p>
<p >If the blocking write option is used (PSoC 6), and write or erase operations are performed by CM4, the user's code on CM0P and CM4 is blocked until the operations are completed. If the operations are performed by CM0P, the user's code on CM4 is not blocked and the user code's on CM0P is blocked until the operation is completed. Plan your task allocation accordingly.</p>
<p >There are restrictions on using the read-while-write (RWW) feature for EEPROM emulation. There are also multiple constraints for blocking and nonblocking flash operations, relating to interrupts, Power modes, IPC usage, etc. Refer to the "Flash (Flash System Routine)" section of the CAT1 Peripheral Driver Library (mtb-pdl-cat1) API Reference Manual.<br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The logical start address in the Em_EEPROM storage to start writing data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eepromData</td><td>Pointer to the start of the data to be writtento Em_EEPROM. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Total size of the data in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to a em_eeprom object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the write operation.<ul>
<li>CY_RSLT_SUCCESS - The operation is successfully completed.</li>
<li>MTB_EM_EEPROM_BAD_CHECKSUM - One of the row the data read from contains bad checksum.</li>
<li>MTB_EM_EEPROM_REDUNDANT_COPY_USED - Some data were read from redundant copy.</li>
<li>MTB_EM_EEPROM_WRITE_FAIL - The write operation is failed.</li>
<li>MTB_EM_EEPROM_BAD_PARAM - The function input parameter is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad61dbc3c01d2bbf96e0c0d5b6d2e0b61" name="gad61dbc3c01d2bbf96e0c0d5b6d2e0b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad61dbc3c01d2bbf96e0c0d5b6d2e0b61">&#9670;&nbsp;</a></span>Cy_Em_EEPROM_Erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__emeeprom.html#ga00cb0e6ed68329cd7aba18e3a93e13d2">cy_en_em_eeprom_status_t</a> Cy_Em_EEPROM_Erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function erases the entire content of Em_EEPROM. </p>
<p >Erased values are all zeros.</p>
<p >In the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_mode_simple">Simple Mode</a> the function just erases the entire content of Em_EEPROM.</p>
<p >When Simple Mode is disabled, the function first performs one write operation to keep the number of writes completed so far and then erases all rest content of Em_EEPROM memory. So, the <a class="el" href="group__group__emeeprom.html#gad7fb39640526ce706a7867d955d2b275" title="Returns the number of the Em_EEPROM Writes completed so far.">Cy_Em_EEPROM_NumWrites()</a> function returns the correct value. Refer to the <a class="el" href="group__group__emeeprom.html#gaa792ff05d2b6ee71b44f1faeb2b68886" title="Writes data to a specified location.">Cy_Em_EEPROM_Write()</a> function for the side effect of the write operation. If the write operation is failed then corresponding status is returned and no erase operation is executed.</p>
<p >This function uses a buffer of the flash row size to perform the erase operation. For the size of the row, refer to the specific PSoC device datasheet.</p>
<p >This is a blocking function and it does not return until the erase operation is completed. The user's application program cannot enter Hibernate mode until the write is completed. The write operation is allowed in CPU Sleep mode. Do not reset your device during the flash operation, including the XRES pin, a software reset, and watchdog reset sources. Also, configure low-voltage detect circuits to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.</p>
<p >If the blocking write option is used, and write or erase operations are performed by CM4, the user's code on CM0P and CM4 is blocked until the operations are completed. If the operations are performed by CM0P, the user's code on CM4 is not blocked and the user code's on CM0P is blocked until the operation is completed. Plan your task allocation accordingly.</p>
<p >There are restrictions on using the read-while-write (RWW) feature for EEPROM emulation. There are also multiple constraints for blocking and nonblocking flash operations, relating to interrupts, power mode, IPC usage, etc. Refer to the "Flash (Flash System Routine)" section of the CAT1 Peripheral Driver Library (mtb-pdl-cat1) API Reference Manual.<br  />
 Also, refer to the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_miscellaneous">Limitations and Restrictions</a> section for the different Em_EEPROM middleware restrictions and limitations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to a em_eeprom object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the erase operation.<ul>
<li>CY_RSLT_SUCCESS - The operation is successfully completed.</li>
<li>CY_EM_EEPROM_WRITE_FAIL - The either Write or Erase operation is failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad7fb39640526ce706a7867d955d2b275" name="gad7fb39640526ce706a7867d955d2b275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7fb39640526ce706a7867d955d2b275">&#9670;&nbsp;</a></span>Cy_Em_EEPROM_NumWrites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_Em_EEPROM_NumWrites </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__emeeprom.html#structcy__stc__eeprom__context__t">cy_stc_eeprom_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of the Em_EEPROM Writes completed so far. </p>
<p >This function returns zero in the <a class="el" href="group__group__emeeprom.html#section_em_eeprom_mode_simple">Simple Mode</a> since the number of writes is not available in this case.</p>
<p >Use this function to monitor the flash memory endurance. The higher the value, the less the flash memory endurance. Refer to the datasheet write endurance spec to determine the maximum number of write cycles. If the Wear Leveling feature is enabled, then the maximum of write cycles is increased by <a class="el" href="group__group__emeeprom.html#a73845ac1bd1d2c5b4eafd9efc86f7fa9">cy_stc_eeprom_context_t::wearLevelingFactor</a>.</p>
<p >The returned number does not include the number of writes into the redundant copy if enabled.</p>
<p >This function does the following:</p><ol type="1">
<li>Returns the number of writes stored in the the last written row if the checksum of the row is correct.</li>
<li>If the checksum of the last written row is invalid and the redundant copy feature is enabled, then the row checksum of the redundant copy is verified for correctness and corresponding number of writes is returned.</li>
<li>If the checksum of the last written row is incorrect, then a special algorithm of searching the last written is executed and a corresponding number of writes is reported.</li>
<li>If the algorithm is unable to find the last written row (there is no row with the correct checksum), then zero is returned.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to a em_eeprom object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of writes performed to the Em_EEPROM. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Emulated EEPROM (emeeprom)</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
